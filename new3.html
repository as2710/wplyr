<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
    <title>Progress‑Bar Audio Player — Mobile Friendly UI (Background Indicator)</title>
    <style>
        :root{
          --bg:#061025; --panel:#0f1730; --muted:#9aa3b2; --accent:#7c9cff; --accent2:#57e3a0; --glass:rgba(255,255,255,0.04);
          --gap:12px; --pad:12px; --radius:12px; --btn-h:44px;
        }
        *{box-sizing:border-box}
        html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,var(--bg),#08102a);color:#e6ebff;-webkit-font-smoothing:antialiased}

        header{position:sticky;top:0;z-index:30;background:linear-gradient(180deg,rgba(6,16,37,0.92),rgba(6,14,30,0.85));border-bottom:1px solid rgba(255,255,255,0.03);backdrop-filter:blur(6px)}
        .container{max-width:980px;margin:0 auto;padding:var(--pad)}

        /* header layout */
        .topRow{display:flex;gap:var(--gap);align-items:center;flex-wrap:wrap}
        .fileInputWrap{display:flex;gap:8px;align-items:center;flex:1 1 240px}
        input[type=file]{display:block}

        .globalWrap{display:flex;gap:8px;align-items:center}
        .globalBtns{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
        .globalBtns .btn{height:var(--btn-h);min-width:52px;padding:0 10px}

        .masterControls{display:flex;gap:8px;align-items:center}
        .masterControls input[type=range]{width:120px}

        /* grid and card */
        .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(320px,1fr));gap:12px;margin:var(--gap) 0}
        .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:14px;padding:12px;border:1px solid var(--glass);box-shadow:0 10px 24px rgba(2,6,18,0.6)}

        .meta{display:flex;justify-content:space-between;align-items:center;gap:8px}
        .title{font-weight:700;font-size:15px}
        .tiny{font-size:13px;color:var(--muted)}

        .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
        .btn{background:transparent;border-radius:10px;padding:10px 12px;border:1px solid rgba(255,255,255,0.06);cursor:pointer;color:inherit;font-weight:600}
        .btn.toggle{min-width:64px}
        .btn[aria-pressed="true"]{background:linear-gradient(90deg,var(--accent),var(--accent2));color:#04102a;border-color:transparent;box-shadow:0 8px 22px rgba(92,120,255,0.12)}
        .btn.remove{border-color:rgba(255,80,80,0.12);color:#ffb3b3}

        progress{width:100%;height:12px;border-radius:8px;background:rgba(255,255,255,0.03);-webkit-appearance:none}
        progress::-webkit-progress-value{background:linear-gradient(90deg,var(--accent),var(--accent2))}
        .seek{width:100%;margin-top:8px}

        .controls-right{display:flex;flex-direction:column;align-items:flex-end;gap:8px}
        .speedRow,.volRow{display:flex;align-items:center;gap:8px}
        .speedValue,.volVal{min-width:56px;text-align:center;font-weight:700}

        .bgBadge{margin-left:8px;padding:4px 8px;border-radius:10px;font-size:12px;font-weight:700;background:rgba(255,211,77,0.12);color:#ffd34d}

        /* compact mobile-friendly layout */
        @media (max-width:760px){
          .container{padding:10px}
          .grid{grid-template-columns:1fr}
          .topRow{align-items:flex-start}
          .globalWrap{flex:1 1 100%;justify-content:space-between}
          .globalBtns{gap:6px}
          .globalBtns .btn{height:44px;padding:8px 10px;font-size:14px}
          .masterControls{gap:6px}
          .masterControls input[type=range]{width:100px}
          .controls-right{align-items:flex-start}
          .controls{gap:6px}
          .btn{padding:10px;border-radius:12px}
          .speedRow,.volRow{width:100%;justify-content:space-between}
        }

        /* touch target improvements */
        button,input[type=range],select{touch-action:manipulation}
    </style>
</head>
<body>
<header>
    <div class="container topRow">
        <div class="fileInputWrap">
            <label class="tiny" for="filePicker">Select audio files</label>
            <input id="filePicker" type="file" accept="audio/*,.wav,.flac,.mp3,.m4a,.ogg" multiple />
        </div>

        <div class="globalWrap">
            <div class="globalBtns" role="toolbar" aria-label="Global controls">
                <button id="gPlay" class="btn toggle" aria-pressed="false">Play all</button>
                <button id="gPause" class="btn toggle" aria-pressed="false">Pause all</button>
                <button id="gStop" class="btn toggle" aria-pressed="false">Stop all</button>
                <button id="gLoop" class="btn toggle" aria-pressed="false">Loop all</button>
                <button id="gSound" class="btn toggle" aria-pressed="false">Sound all</button>
            </div>

            <div class="masterControls" aria-hidden="false">
                <label class="tiny">Master Vol</label>
                <input id="masterVol" type="range" min="0" max="1" step="0.01" value="1" />
                <div id="masterVolDb" class="tiny">0.0 dB</div>
                <button id="masterMute" class="btn toggle" aria-pressed="false">Mute</button>
                <!-- background indicator + notification request -->
                <div id="bgHeaderIndicator" class="bgBadge" style="display:none">Background playing</div>
                <button id="requestNotif" class="btn" style="margin-left:6px">Enable notifications</button>
            </div>
        </div>
    </div>
</header>

<main class="container">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;margin-top:10px">
        <div class="tiny">Global settings</div>
        <div>
            <label class="tiny">Tick</label>
            <select id="tickMs"><option>50</option><option selected>100</option><option>250</option><option>500</option></select>
        </div>
    </div>

    <div id="cards" class="grid" aria-live="polite"></div>
</main>

<script>
    // Script preserved with same behavior; background playback indicator and notification integration added
    const $ = (s,el=document)=>el.querySelector(s);
    const $$ = (s,el=document)=>Array.from(el.querySelectorAll(s));
    const cards = $('#cards');
    const state = new Map();
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    let wakeLock = null; let manualWake = false;
    async function requestWake(){ if(!('wakeLock' in navigator)) return false; try{ if(wakeLock) return true; wakeLock = await navigator.wakeLock.request('screen'); wakeLock.addEventListener('release', ()=>{ wakeLock=null; updateWakeUI(); }); updateWakeUI(); return true;}catch(e){wakeLock=null;updateWakeUI();return false;} }
    async function releaseWake(){ if(!('wakeLock' in navigator)) return false; try{ if(wakeLock){ await wakeLock.release(); wakeLock=null; updateWakeUI(); } return true; }catch(e){return false;} }
    function updateWakeUI(){ const modeEl = $('#wakeMode'); if(!modeEl) return; if(manualWake){ modeEl.textContent='Manual'; $('#wakeToggle')?.setAttribute('aria-pressed','true'); } else if(wakeLock){ modeEl.textContent='Auto'; $('#wakeToggle')?.setAttribute('aria-pressed','false'); } else { modeEl.textContent='Off'; $('#wakeToggle')?.setAttribute('aria-pressed','false'); } }
    document.addEventListener('visibilitychange', async ()=>{ if(document.visibilityState==='visible' && (manualWake || anyPlaying())) await requestWake(); });
    function anyPlaying(){ return Array.from(state.values()).some(c=>c.playing && !c.paused); }
    function updateAutoWake(){ if(manualWake) return; if(anyPlaying()) requestWake(); else releaseWake(); }

    // Master volume
    let masterVolume = 1.0; let masterMuted = false;
    function volToDb(v){ if(v<=0) return '-∞'; return (20*Math.log10(v)).toFixed(1) + ' dB'; }
    $('#masterVol').addEventListener('input', ()=>{ masterVolume = parseFloat($('#masterVol').value); $('#masterVolDb').textContent = volToDb(masterVolume); applyMasterVolume(); });
    $('#masterMute').addEventListener('click', ()=>{ masterMuted = !masterMuted; $('#masterMute').setAttribute('aria-pressed', masterMuted?'true':'false'); applyMasterVolume(); });
    function applyMasterVolume(){ for(const c of state.values()){ if(c.audioEl){ try{ c.audioEl.volume = (c.muted?0: (c.volume * masterVolume * (masterMuted?0:1))); }catch(e){} } const infoEl = document.getElementById('volInfo-'+c.id); if(infoEl) infoEl.textContent = `${Math.round(c.volume*100)}% / ${volToDb(c.volume)}`; } $('#masterVolDb').textContent = masterMuted? '-∞' : volToDb(masterVolume); }

    // playback notification helpers
    let _playNotif = null;
    document.getElementById('requestNotif')?.addEventListener('click', async ()=>{
      if (!('Notification' in window)) { alert('Notifications not supported'); return; }
      const perm = await Notification.requestPermission(); if(perm==='granted') document.getElementById('requestNotif').style.display='none';
    });

    function showPlaybackNotification(){ if (!('Notification' in window)) return; if (Notification.permission !== 'granted') return; try{ if(_playNotif) _playNotif.close(); }catch(e){}
      const playingCount = Array.from(state.values()).filter(c=>c.playing && !c.paused).length; const title = 'Playback running'; const body = playingCount>1?`${playingCount} tracks playing`:'1 track playing'; _playNotif = new Notification(title,{body,tag:'audio-playback-indicator',renotify:true,silent:true}); _playNotif.onclick = ()=>{ try{ window.focus(); }catch(e){} _playNotif.close(); } }
    function closePlaybackNotification(){ try{ if(_playNotif) _playNotif.close(); _playNotif=null; }catch(e){} }

    // header and per-file background indicators
    function setHeaderBgIndicator(show){ const el = document.getElementById('bgHeaderIndicator'); if(!el) return; el.style.display = show ? 'inline-block' : 'none'; }
    function setPerFileBgBadge(ctrl, show){ if(!ctrl) return; if(!ctrl._bgBadge){ try{ const card = document.getElementById('card-'+ctrl.id); if(!card) return; const meta = card.querySelector('.meta'); const span = document.createElement('span'); span.className='bgBadge'; span.textContent='Background'; span.style.display='none'; meta.appendChild(span); ctrl._bgBadge = span; }catch(e){} } if(ctrl._bgBadge) ctrl._bgBadge.style.display = show ? 'inline-block' : 'none'; }

    function updateMediaSession(){ if(!('mediaSession' in navigator)) return; const active = Array.from(state.values()).find(c=>c.playing && !c.paused); if(!active){ navigator.mediaSession.metadata = null; return; } try{ navigator.mediaSession.metadata = new MediaMetadata({ title: active.file?.name || 'Audio', artist: 'Player' }); navigator.mediaSession.setActionHandler('play', ()=>{ playCtrl(active); }); navigator.mediaSession.setActionHandler('pause', ()=>{ pauseCtrl(active); }); navigator.mediaSession.setActionHandler('stop', ()=>{ stopCtrl(active); }); navigator.mediaSession.setActionHandler('seekto', (details)=>{ if(!details||typeof details.seekTime!=='number') return; if(active.decoded){ active.offset = Math.round(details.seekTime * (active.sr || 48000)); setProgFromFraction(active, Math.min(1, details.seekTime / active.decoded.duration)); if(active.sound && active.audioEl) try{ active.audioEl.currentTime = details.seekTime; }catch(e){} } }); }catch(e){}
    }

    async function handleVisibilityChange(){ const hidden = document.visibilityState==='hidden'; const playing = anyPlaying(); setHeaderBgIndicator(hidden && playing); for(const ctrl of state.values()){ setPerFileBgBadge(ctrl, hidden && ctrl.playing && !ctrl.paused); } if(hidden && playing) showPlaybackNotification(); else closePlaybackNotification(); updateMediaSession(); }
    document.addEventListener('visibilitychange', handleVisibilityChange);

    // call when playback state changes
    function notifyBackgroundState(){ handleVisibilityChange(); }

    // global buttons
    $('#gPlay').addEventListener('click', ()=>{ for(const c of state.values()) playCtrl(c); setGlobalToggle('gPlay',true); setGlobalToggle('gPause',false); notifyBackgroundState(); });
    $('#gPause').addEventListener('click', ()=>{ for(const c of state.values()) pauseCtrl(c); setGlobalToggle('gPause',true); setGlobalToggle('gPlay',false); notifyBackgroundState(); });
    $('#gStop').addEventListener('click', ()=>{ for(const c of state.values()) stopCtrl(c); setGlobalToggle('gStop',true); setGlobalToggle('gPlay',false); setGlobalToggle('gPause',false); notifyBackgroundState(); });
    $('#gLoop').addEventListener('click', ()=>{ const pressed = $('#gLoop').getAttribute('aria-pressed')==='true'; const next = !pressed; for(const c of state.values()){ c.loop = next; c.loopEl.checked = next; } setGlobalToggle('gLoop', next); notifyBackgroundState(); });
    $('#gSound').addEventListener('click', ()=>{ const pressed = $('#gSound').getAttribute('aria-pressed')==='true'; const next = !pressed; for(const c of state.values()){ c.sound = next && !!c.file && !!c.decoded; if(c.sound && c.playing && !c.paused) startAudioElement(c); else stopAudioElement(c); c.soundEl.checked = c.sound; } setGlobalToggle('gSound', next); updateGlobalSoundButton(); notifyBackgroundState(); });

    $('#tickMs').addEventListener('change', ()=>{ const t = parseInt($('#tickMs').value,10); for(const c of state.values()){ c.tick = t; if(c.playing && !c.paused){ clearInterval(c.timer); startLoopFor(c); } } });

    // master volume
    $('#masterVol').addEventListener('input', ()=>{ masterVolume = parseFloat($('#masterVol').value); $('#masterVolDb').textContent = volToDb(masterVolume); applyMasterVolume(); notifyBackgroundState(); });
    $('#masterMute').addEventListener('click', ()=>{ masterMuted = !masterMuted; $('#masterMute').setAttribute('aria-pressed', masterMuted?'true':'false'); applyMasterVolume(); notifyBackgroundState(); });

    function fmtBytes3(n){ const u=['B','KB','MB','GB']; let i=0; let v=n; while(v>=1024 && i<u.length-1){ v/=1024; i++; } return `${v.toFixed(i===0?0:3)} ${u[i]}`; }
    function fmtTime(sec){ if(!isFinite(sec)) return '—'; const m=Math.floor(sec/60); const s=Math.floor(sec%60); return `${m}:${s.toString().padStart(2,'0')}`; }

    // core playback & UI functions (kept behavior; added notifyBackgroundState calls)
    function applyMasterVolume(){ for(const c of state.values()){ if(c.audioEl){ try{ c.audioEl.volume = (c.muted?0: (c.volume * masterVolume * (masterMuted?0:1))); }catch(e){} } const infoEl = document.getElementById('volInfo-'+c.id); if(infoEl) infoEl.textContent = `${Math.round(c.volume*100)}% / ${volToDb(c.volume)}`; } $('#masterVolDb').textContent = masterMuted? '-∞' : volToDb(masterVolume); }

    function startLoopFor(ctrl){ clearInterval(ctrl.timer); const ms = Math.max(20, ctrl.tick); ctrl.timer = setInterval(()=>advance(ctrl), ms); }
    function advance(ctrl){ if(ctrl.paused||ctrl.stopped) return; if(ctrl.sound && ctrl.audioEl && !ctrl.audioEl.paused){ const cur = Math.max(0, ctrl.audioEl.currentTime || 0); ctrl.offset = Math.round(cur * (ctrl.sr || 48000)); const total = ctrl.decoded ? ctrl.decoded.duration : (ctrl.duration || Math.max(1, (new Uint8Array(ctrl.buf)).length / 48000)); setProgFromFraction(ctrl, Math.min(1, cur / total)); updateUI(ctrl); return; }
      if(ctrl.mode==='pcm' && ctrl.decoded){ const sr = ctrl.sr; const samplesPerTick = Math.max(1, Math.round(sr*(ctrl.tick/1000)*ctrl.rate)); const totalSamples = Math.round(ctrl.decoded.duration*sr); ctrl.offset = Math.min(totalSamples, ctrl.offset + samplesPerTick); const frac = ctrl.offset / totalSamples; setProgFromFraction(ctrl, frac); updateUI(ctrl); if(ctrl.offset>=totalSamples) return finish(ctrl); } else { const u=new Uint8Array(ctrl.buf); const total=u.length; const dur = ctrl.duration || Math.max(1, total/48000); const bytesPerTick = Math.max(1, Math.round((total/dur)*(ctrl.tick/1000)*ctrl.rate)); ctrl.offset = Math.min(total, ctrl.offset + bytesPerTick); const frac=ctrl.offset/total; setProgFromFraction(ctrl,frac); updateUI(ctrl); if(ctrl.offset>=total) return finish(ctrl); } }

    function finish(ctrl){ stopAudioElement(ctrl); if(ctrl.loop){ ctrl.offset=0; setProgFromFraction(ctrl,0); updateUI(ctrl); if(ctrl.sound && ctrl.playing && !ctrl.paused) setTimeout(()=>startAudioElement(ctrl),10); ctrl.statusEl.textContent='Looping'; notifyBackgroundState(); return; } clearInterval(ctrl.timer); ctrl.playing=false; ctrl.paused=false; ctrl.stopped=true; ctrl.statusEl.textContent='Completed'; setButtonStates(ctrl); updateGlobalButtons(); updateAutoWake(); notifyBackgroundState(); }

    function playCtrl(ctrl){ if(ctrl.playing && ctrl.paused){ ctrl.paused=false; startLoopFor(ctrl); if(ctrl.sound) startAudioElement(ctrl); ctrl.statusEl.textContent='Resumed'; setButtonStates(ctrl); updateGlobalButtons(); updateAutoWake(); notifyBackgroundState(); return; } if(ctrl.playing) return; ctrl.playing=true; ctrl.paused=false; ctrl.stopped=false; startLoopFor(ctrl); if(ctrl.sound) startAudioElement(ctrl); ctrl.statusEl.textContent='Playing'; setButtonStates(ctrl); updateGlobalButtons(); updateAutoWake(); notifyBackgroundState(); }
    function pauseCtrl(ctrl){ if(!ctrl.playing||ctrl.paused) return; ctrl.paused=true; clearInterval(ctrl.timer); if(ctrl.sound && ctrl.audioEl) try{ ctrl.audioEl.pause(); }catch(e){} ctrl.statusEl.textContent='Paused'; setButtonStates(ctrl); updateGlobalButtons(); updateAutoWake(); notifyBackgroundState(); }
    function stopCtrl(ctrl){ clearInterval(ctrl.timer); if(ctrl.sound) stopAudioElement(ctrl); ctrl.playing=false; ctrl.paused=false; ctrl.stopped=true; ctrl.offset=0; setProgFromFraction(ctrl,0); updateUI(ctrl); ctrl.statusEl.textContent='Stopped'; setButtonStates(ctrl); updateGlobalButtons(); updateAutoWake(); notifyBackgroundState(); }

    function removeTrack(ctrl){ try{ stopCtrl(ctrl); stopAudioElement(ctrl); revokeAudioUrl(ctrl); const el=document.getElementById('card-'+ctrl.id); if(el) el.remove(); state.delete(ctrl.id); updateGlobalButtons(); updateGlobalSoundButton(); updateAutoWake(); notifyBackgroundState(); }catch(e){} }

    // audio element helpers
    function makeBlobUrl(file){ try{return URL.createObjectURL(file);}catch(e){return null;} }
    function startAudioElement(ctrl){ if(!ctrl.file) return; if(!ctrl.audioUrl) ctrl.audioUrl = makeBlobUrl(ctrl.file); if(!ctrl.audioUrl) return; if(!ctrl.audioEl){ const a=new Audio(); a.src = ctrl.audioUrl; a.preload='auto'; a.crossOrigin='anonymous'; a.preservesPitch = true; ctrl.audioEl = a; a.addEventListener('timeupdate', ()=>{ if(ctrl.sound && ctrl.playing && !ctrl.paused){ const cur = ctrl.audioEl.currentTime || 0; ctrl.offset = Math.round(cur * (ctrl.sr || 48000)); const total = ctrl.decoded?ctrl.decoded.duration:(ctrl.duration||Math.max(1,(new Uint8Array(ctrl.buf)).length/48000)); setProgFromFraction(ctrl, Math.min(1, cur/total)); updateUI(ctrl); } }); a.addEventListener('ended', ()=>{ stopAudioElement(ctrl); }); }
      try{ ctrl.audioEl.playbackRate = ctrl.rate || 1; ctrl.audioEl.volume = (ctrl.muted?0: (ctrl.volume * masterVolume * (masterMuted?0:1))); const pos = Math.max(0, Math.min((ctrl.decoded?ctrl.decoded.duration:(ctrl.duration||0.1)), ctrl.offset / (ctrl.sr || 48000))); try{ ctrl.audioEl.currentTime = pos; }catch(e){} ctrl.audioEl.play().catch(()=>{}); }catch(e){}
    }
    function stopAudioElement(ctrl){ try{ if(ctrl.audioEl){ try{ ctrl.audioEl.pause(); }catch(e){} } }catch(e){} }
    function revokeAudioUrl(ctrl){ try{ if(ctrl.audioUrl){ URL.revokeObjectURL(ctrl.audioUrl); ctrl.audioUrl=null; } }catch(e){} }

    // UI helpers
    function setButtonStates(ctrl){ ctrl.playBtn.setAttribute('aria-pressed', (ctrl.playing && !ctrl.paused) ? 'true':'false'); ctrl.pauseBtn.setAttribute('aria-pressed', (ctrl.playing && ctrl.paused)?'true':'false'); ctrl.stopBtn.setAttribute('aria-pressed', (ctrl.stopped)?'true':'false'); }
    function updateGlobalButtons(){ const anyPlaying = Array.from(state.values()).some(c=>c.playing && !c.paused); const anyPaused = Array.from(state.values()).some(c=>c.playing && c.paused); const anyStopped = Array.from(state.values()).every(c=>c.stopped || !c.playing); setGlobalToggle('gPlay', anyPlaying); setGlobalToggle('gPause', anyPaused); setGlobalToggle('gStop', anyStopped); updateGlobalLoopButton(); updateAutoWake(); }
    function updateGlobalLoopButton(){ const allLoop = Array.from(state.values()).length>0 && Array.from(state.values()).every(c=>c.loop); setGlobalToggle('gLoop', allLoop); }
    function updateGlobalSoundButton(){ const allSound = Array.from(state.values()).length>0 && Array.from(state.values()).every(c=>c.sound); setGlobalToggle('gSound', allSound); }
    function setGlobalToggle(id,pressed){ const el=$('#'+id); if(el) el.setAttribute('aria-pressed', pressed?'true':'false'); }

    function setProgFromFraction(c,frac){ c.prog.value = Math.max(0,Math.min(1,frac)); c.seek.value = Math.round(frac*1000); }
    function setOffsetFromFraction(c,frac){ if(c.mode==='pcm' && c.decoded){ const totalSamples=Math.round(c.decoded.duration*c.sr); c.offset = Math.round(frac*totalSamples); } else { const u=new Uint8Array(c.buf); c.offset = Math.round(frac*u.length); } }
    function updateUI(c){ const total=c.mode==='pcm'&&c.decoded?c.decoded.duration:(c.duration||Math.max(1,(new Uint8Array(c.buf)).length/48000)); const cur=c.mode==='pcm'&&c.decoded?(c.offset/c.sr):((c.offset/(new Uint8Array(c.buf)).length)*total); c.timeEl.textContent = `${fmtTime(cur)} / ${fmtTime(total)}`; setButtonStates(c); }

    // add card and wiring
    $('#filePicker').addEventListener('change', async e=>{ for(const f of e.target.files) await addCard(f); e.target.value=''; });
    async function addCard(file){ const id = Math.random().toString(36).slice(2)+Date.now().toString(36); const card = document.createElement('div'); card.className='card'; card.id='card-'+id; card.innerHTML = `
        <div class="meta">
          <div>
            <div class="title">${file.name}</div>
            <div class="tiny" id="size-${id}">${fmtBytes3(file.size)}</div>
          </div>
          <div>
            <label class="tiny"><input type="checkbox" id="loop-${id}"/> Loop</label>
          </div>
        </div>

        <div style="margin-top:10px">
          <progress id="prog-${id}" value="0" max="1"></progress>
          <input id="seek-${id}" class="seek" type="range" min="0" max="1000" value="0" />
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px">
          <div class="controls">
            <button id="play-${id}" class="btn btn-small" aria-pressed="false">Play</button>
            <button id="pause-${id}" class="btn btn-small" aria-pressed="false">Pause</button>
            <button id="stop-${id}" class="btn btn-small" aria-pressed="false">Stop</button>
            <label class="tiny" style="margin-left:8px"><input type="checkbox" id="sound-${id}"/> Sound</label>
            <button id="remove-${id}" class="btn remove">Remove</button>
          </div>

          <div class="controls-right">
            <div class="speedRow">
              <label class="tiny">Speed</label>
              <input id="rate-${id}" type="range" min="0.5" max="2" step="0.01" value="1" />
              <div id="speedVal-${id}" class="speedValue">1.000×</div>
            </div>

            <div class="volRow" style="margin-top:8px">
              <label class="tiny">Vol</label>
              <input id="vol-${id}" type="range" min="0" max="1" step="0.01" value="1" style="width:100px" />
              <div id="volInfo-${id}" class="volVal">100% / 0.0 dB</div>
              <button id="mute-${id}" class="btn toggle" aria-pressed="false">Mute</button>
            </div>

            <div style="display:flex;gap:10px;align-items:center;margin-top:6px">
              <div class="tiny" id="status-${id}">Idle</div>
              <div class="tiny time" id="time-${id}">0:00 / —</div>
            </div>
          </div>
        </div>`;
      cards.prepend(card);

      const buf = await file.arrayBuffer(); let decoded=null,duration=null,sr=null,ch=null; try{ decoded = await audioCtx.decodeAudioData(buf.slice(0)); duration=decoded.duration; sr=decoded.sampleRate; ch=decoded.numberOfChannels; }catch(e){}

      const prog = $(`#prog-${id}`), seek = $(`#seek-${id}`), playBtn = $(`#play-${id}`), pauseBtn = $(`#pause-${id}`), stopBtn = $(`#stop-${id}`), rateEl = $(`#rate-${id}`), speedValEl = $(`#speedVal-${id}`), statusEl = $(`#status-${id}`), timeEl = $(`#time-${id}`), loopEl = $(`#loop-${id}`), sizeEl = $(`#size-${id}`), soundEl = $(`#sound-${id}`), volEl = $(`#vol-${id}`), volInfo = $(`#volInfo-${id}`), muteBtn = $(`#mute-${id}`), removeBtn = $(`#remove-${id}`);

      sizeEl.textContent = fmtBytes3(file.size);

      const ctrl = { id, file, buf, decoded, duration: duration||null, sr, ch, mode: decoded? 'pcm':'bytes', playing:false, paused:false, stopped:true, offset:0, tick:parseInt($('#tickMs').value,10), rate:1, timer:null, prog, seek, statusEl, timeEl, loop:false, loopEl, speedValEl, playBtn, pauseBtn, stopBtn, soundEl, volEl, volInfo, muteBtn, removeBtn, audioEl:null, audioUrl:null, sound:false, volume:1, muted:false };

      if(!decoded){ soundEl.disabled=true; soundEl.title='Audio output unavailable'; volEl.disabled=true; muteBtn.disabled=true; volInfo.textContent = '—'; }

      loopEl.addEventListener('change', ()=>{ ctrl.loop = loopEl.checked; updateGlobalLoopButton(); notifyBackgroundState(); });
      rateEl.addEventListener('input', ()=>{ ctrl.rate = parseFloat(rateEl.value); speedValEl.textContent = ctrl.rate.toFixed(3)+'×'; if(ctrl.audioEl) try{ ctrl.audioEl.playbackRate = ctrl.rate; }catch(e){} });

      function refreshVolInfo(){ volInfo.textContent = `${Math.round(ctrl.volume*100)}% / ${volToDb(ctrl.volume)}`; }
      volEl.addEventListener('input', ()=>{ ctrl.volume = parseFloat(volEl.value); refreshVolInfo(); if(ctrl.audioEl) try{ ctrl.audioEl.volume = (ctrl.muted?0: (ctrl.volume * masterVolume * (masterMuted?0:1))); }catch(e){} updateGlobalSoundButton(); notifyBackgroundState(); });

      muteBtn.addEventListener('click', ()=>{ ctrl.muted = !ctrl.muted; muteBtn.setAttribute('aria-pressed', ctrl.muted?'true':'false'); if(ctrl.audioEl) try{ ctrl.audioEl.volume = (ctrl.muted?0: (ctrl.volume * masterVolume * (masterMuted?0:1))); }catch(e){} refreshVolInfo(); notifyBackgroundState(); });

      soundEl.addEventListener('change', async ()=>{ ctrl.sound = !!soundEl.checked && !!ctrl.file && !!ctrl.decoded; if(ctrl.sound && ctrl.playing && !ctrl.paused){ try{ if(audioCtx.state==='suspended') await audioCtx.resume(); startAudioElement(ctrl); }catch(e){} } else { stopAudioElement(ctrl); } updateGlobalSoundButton(); notifyBackgroundState(); });

      removeBtn.addEventListener('click', ()=>{ removeTrack(ctrl); });

      seek.addEventListener('input', ()=>{ const frac = parseInt(seek.value,10)/1000; setOffsetFromFraction(ctrl, frac); if(ctrl.sound && ctrl.playing && !ctrl.paused){ try{ if(ctrl.audioEl){ ctrl.audioEl.currentTime = Math.max(0, ctrl.offset/(ctrl.sr||48000)); } else { startAudioElement(ctrl); } }catch(e){} } updateUI(ctrl); updateGlobalButtons(); notifyBackgroundState(); });

      playBtn.addEventListener('click', ()=>{ playCtrl(ctrl); }); pauseBtn.addEventListener('click', ()=>{ pauseCtrl(ctrl); }); stopBtn.addEventListener('click', ()=>{ stopCtrl(ctrl); });

      refreshVolInfo(); updateUI(ctrl); setButtonStates(ctrl); state.set(id, ctrl); updateGlobalButtons(); updateGlobalSoundButton(); applyMasterVolume(); }

</script>
</body>
</html>
